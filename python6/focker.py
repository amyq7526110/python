#!/usr/bin/env python3
import os

# forking工作原理

#   什么是forking
#   •  fork(分岔)在Linux系统中使用非常广泛
#   •  当某一命令执行时,父进程(当前进程)fork出一个
#   子进程
#   •  父进程将自身资源拷贝一份,命令在子进程中运行时,
#   就具有和父进程完全一样的运行环境

#   进程的生命周期
#   •  父进程fork出子进程并挂起
#   •  子进程运行完毕后,释放大部分资源并通知父进程,
#   这个时候,子进程被称作僵尸进程
#   •  父进程获知子进程结束,子进程所有资源释放



#  僵尸进程
#  •  僵尸进程没有任何可执行代码,也不能被调度
#  •  如果系统中存在过多的僵尸进程,将因为没有可用的
#  进程号而导致系统不能产生新的进程
#  •  对于系统管理员来说,可以试图杀死其父进程或重启
#  系统来消除僵尸进程

#  forking编程

#  forking编程基本思路
#  •  需要使用os模块
#  •  os.fork()函数实现forking功能
#  •  python中,绝大多数的函数只返回一次,os.fork将
#  返回两次
#  •  对fork()的调用,针对父进程返回子进程的PID;对于
#  子进程,返回PID0

print('hello world')

pid = os.fork()

if pid:
    print('父进程。。。。。。。。')
else:
    print('子进程。。。。。。。。')

print('你好！')    

# 一定要明确父子进程的分工

# 一般来说父进程值用来生成 子进程（用来干活）

# 子进程要结束！！！！

#   forking编程基本思路(续1)
#   •  因为所有的父子进程拥有相同的资源,所以在编写程
#   序时要避免资源冲突
#   网络编程思路如下:   
#   pidbox= os.fork()     #实现forking
#   if pid:               #在父进程中关闭子进程连接   
#       close_child_conn  #接着处理其他的连接请求 
#       handle_more_conn
#   else:                 #子进程关闭父进程连接,响应当    
#       close_parent_conn #前的用户连接  
#       process_this_conn
















